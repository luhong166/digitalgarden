---
{"dg-publish":true,"permalink":"/Spaces/2-Areas/Python学习/第05章-组合数据类型/"}
---

# 一、序列和索引
**序列**是一个用于存储多个值的连续空间，每个值都对应一个整数的编号，称为**索引**。在Python当中，序列的索引有正向递增和反向递减
![5-1序列](/img/user/Extras/Media/5-1序列.png)
属于序列结构的有字符串、列表、元组、集合和字典。其中字符串、列表和元组叫有序序列，集合和字典叫无序序列。同时，列表、元组、集合、字典又被称为Python当中的组合数据类型
## 1.序列的切片操作
**切片操作的语法结构：**
![5-2切片操作的语法结构](/img/user/Extras/Media/5-2切片操作的语法结构.png)
通过切片操作后可以生成一个新的序列。
```python
s='HelloWorld'
# 切片操作
s1=s[0:5:2] # 索引从0开始，到5结束（不包含5）步长为2
print(s1)
# 省略了开始位置，start默认从0开始
print(s[:5:1])
# 省略开始位置start，省略步长step
print(s[:5:])
# 省略结束位置
print(s[0::1]) # stop，默认到序列的最后一个元素（包含最后一个元素）

print(s[5::])
print(s[5:]) # 12行代码与13行代码功能相同，省略了结束，省略了一个步长
# 更改一下步长，步长更改为2
print(s[0:5:2])

# 省略开始位置，省略结束位置，只写步长
print(s[::2]) # 分别获取0,2,4,6,8索引位置上的元素

# 步长为负数
print(s[::-1]) # 可以使用哪句代码替换呢
print(s[-1:-11:-1])
```
输出：
```
Hlo
Hello
Hello
HelloWorld
World
World
Hlo
Hlool
dlroWolleH
dlroWolleH
```
## 2.序列的相加和相乘操作
序列相加操作：
![5-3序列相加操作](/img/user/Extras/Media/5-3序列相加操作.png)
示例：
```python
s='Hello'
s2='World'
# 序列的相加操作
print(s+s2) # 产生一个新的字符串序列

# 序列的相乘操作
print(s*5)
print('-'*40)
```
输出：
```
HelloWorld
HelloHelloHelloHelloHello
----------------------------------------
```
## 3.序列的操作符和函数
|操作符/函数|描述说明|
|:-:|:-:|
|x in s|如果x是s的元素，结果为True，否则结果为False|
|x not in s|如果x不是s的元素，结果为True，否则结果为False|
|len(s)|序列s中元素的个数（即序列的长度）|
|max(s)|序列s中元素的最大值|
|min(s)|序列s中元素的最小值|
|s.index(x)|序列s中第一次出现元素x的位置|
|s.count(x)|序列s中出现x的总次数|
> [!举例]-
> ```python
> s='helloworld'
> print('e在helloworld中存在吗？',('e' in s))
> print('v在helloworld中存在吗？',('v' in s))
> # not in 的使用
> print('e在helloworld中不存在吗？',('e' not in s)) # not in的使用
> print('v在helloworld中不存在吗？',('v' not in s))
> 
> # 内置函数的使用
> print('len():',len(s))
> print('max():',max(s))
> print('min():',min(s))
> 
> # 序列对象的方法，使用序列的方法，打点调用
> print('s.index():',s.index('o')) # o在s中第一次出现的索引位置
> #print('s.index():',s.index('v')) # ValueError: substring not found,报错的原因是v在字符串中根本不存在，不存在所以找不到
> print('s.count():',s.count('o')) # 统计o在字符串s中出现的次数
> ```
> 输出：
> ```
> e在helloworld中存在吗？ True
> v在helloworld中存在吗？ False
> e在helloworld中不存在吗？ False
> v在helloworld中不存在吗？ True
> len(): 10
> max(): w
> min(): d
> s.index(): 4
> s.count(): 2
> ```
# 二、列表类型
1. 是指一系列的按特定顺序排列的元素组成
2. 是Python中内置的**可变序列**
3. 在Python中使用[]定义列表，元素与元素之间使用**英文的逗号**分隔
4. 列表中的元素可以是**任意**的**数据类型**

字符串类型、整数类型、浮点数类型都叫不可变数据类型，而列表是Python当中的可变数据类型，也叫可变序列。

## 1.列表的创建方式
列表的创建方式有两种：
### （1）使用[]直接创建列表
**语法结构如下：**
```python
列表名=[element1,element2,....elementN]
```
### （2）使用内置函数list()创建列表
**语法结构如下：**
```python
列表名=list(序列)
```
### 举例：
```python
# 直接使用[]创建列表
lst=['hello','world',98,100.5]
print(lst)

# 可以使用内置的函数list()创建列表
lst2=list('helloworld')
lst3=list(range(1,10,2)) # 从1开始到10结束，步长为2，不包含10
print(lst2)
print(lst3)
```
输出：
```
['hello', 'world', 98, 100.5]
['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd']
[1, 3, 5, 7, 9]
```
## 2.列表的删除
**语法结构如下：**
```python
del 列表名
```
列表是序列中的一种，对序列的操作符、运算符、函数均可以使用
## 3.enumerate枚举函数
列表的遍历操作有三种方式，分别是使用for循环、for循环+索引、使用enumerate函数
**enumerate函数的使用语法结构：**
```python
for index,item in enumerate(lst):
	输出index和item
```
### 列表的三种遍历操作：
```python
lst=['hello','world','python','php']
# 使用遍历循环for遍历列表元素
for item in lst:
    print(item)

# 使用for循环,range()函数,len()函数，根据索引进行遍历
for i in range(0,len(lst)):
    print(i,'-->',lst[i])

# 第三种遍历方式 enumerate()函数
for index,item in enumerate(lst):
    print(index,item) # index是序号，不是索引
# 手动修改序号的起始值
for index,item in enumerate(lst,start=1):
    print(index,item)

for index,item in enumerate(lst,1): # 省略start不写，直接写起始值
    print(index,item)
```
输出：
```
hello
world
python
php
0 --> hello
1 --> world
2 --> python
3 --> php
0 hello
1 world
2 python
3 php
1 hello
2 world
3 python
4 php
```
## 4.列表的相关操作方法
|列表的方法|描述说明|
|:-:|:-:|
|Ist.append(x)|在列表lst最后增加一个元素|
|Ist.insert(index,x)|在列表中第index位置增加一个元素|
|Ist.clear()|清除列表lst中所有元素|
|Ist.pop(index)|将列表lst中第index位置的元素取出，并从列表中将其删除|
|Ist.remove(x)|将列表lst中出现的第一个元素x删除|
|Ist.reverse(x)|将列表lst中的元素反转|
|Ist.copy()|拷贝列表lst中的所有元素，生成一个新的列表|
列表是Python当中的**可变数据类型**，它具有增、删、改、查的方法，在增、删、改的时候，列表的**内存地址是不变的**。
### （1）列表的增加、删除
> [!举例]-
> ```python
> lst=['hello','world','python']
> print('原列表:',lst,id(lst))
> # 增加元素的操作
> lst.append('sql')
> print('增加元素之后:',lst,id(lst))
> 
> # 使用insert(index,x)在指定的index位置上插入元素x
> lst.insert(1,100)
> print(lst)
> 
> # 列表元素的删除操作
> lst.remove('world') 
> print('删除元素之后的列表:',lst,id(lst))
> 
> # 使用pop(index)根据索引将元素取出，然后再删除
> print(lst.pop(1))
> print(lst)
> 
> # 清除列表中所有元素clear()
> # lst.clear()
> # print(lst,id(lst))
> # 输出：[] 2948656310272
> 
> # 列表的反向
> lst.reverse() # 不会产生新的列表，在原列表的基础上进行的
> print(lst)
> 
> # 列表的拷贝，将产生一个新的列表对象
> new_lst=lst.copy()
> print(lst,id(lst))
> print(new_lst,id(new_lst))
> ```
> 输出：
> ```
> 原列表: ['hello', 'world', 'python'] 1991098214400
> 增加元素之后: ['hello', 'world', 'python', 'sql'] 1991098214400
> ['hello', 100, 'world', 'python', 'sql']
> 删除元素之后的列表: ['hello', 100, 'python', 'sql'] 1991098214400
> 100
> ['hello', 'python', 'sql']
> ['sql', 'python', 'hello']
> ['sql', 'python', 'hello'] 1991098214400
> ['sql', 'python', 'hello'] 1991099295872
> ```

### （2）列表的修改
**列表元素的修改：**
```python
lst=['sql', 'python', 'hello']
# 根据索引进行修改元素  
lst[1]='mysql'  
print(lst)
```
输出：
```
['sql', 'mysql', 'hello']
```
### （3）列表的排序
**列表排序的两种方式：**
1. **列表对象的sort方法**

![5-4列表对象的sort方法](/img/user/Extras/Media/5-4列表对象的sort方法.png)
举例：
```python
lst=[4,56,3,78,40,56,89]  
print('原列表:',lst)  
  
# 排序，默认是升序  
lst.sort() # 排序是在原列表的基础上进行的，不会产生新的列表对象  
print('升序:',lst)  
  
# 排序，降序  
lst.sort(reverse=True)  
print('降序:',lst)  
  
print('----------------------------------')  
lst2=['banana','apple','Cat','Orange']  
print('原列表:',lst2)  
# 升序排序，先排大写，再排小写，因为大写的ASCII码值比小写的要小32  
lst2.sort()  
print('升序:',lst2)  
  
# 降序，先排小写，再排大写  
lst2.sort(reverse=True)  
print('降序:',lst2)  
  
# 忽略大小写进行比较  
lst2.sort(key=str.lower) # 注意，这里不能加括号，参数不加括号，调用才加括号  
print(lst2)
```
输出：
```
原列表: [4, 56, 3, 78, 40, 56, 89]
升序: [3, 4, 40, 56, 56, 78, 89]
降序: [89, 78, 56, 56, 40, 4, 3]
----------------------------------
原列表: ['banana', 'apple', 'Cat', 'Orange']
升序: ['Cat', 'Orange', 'apple', 'banana']
降序: ['banana', 'apple', 'Orange', 'Cat']
['apple', 'banana', 'Cat', 'Orange']
```
2. **内置函数sorted()**，用内置的sorted()函数将产生一个新的列表对象
![5-5内置函数sorted()](../../../../Extras/Media/5-5内置函数sorted().png)

> [!举例]-
> ```python
> lst=[4,56,3,78,40,56,89]
> print('原列表:',lst)
> # 排序
> asc_lst=sorted(lst)
> print('升序:',asc_lst)
> print('原列表:',lst)
> 
> # 降序
> desc_lst=sorted(lst,reverse=True)
> print('降序:',desc_lst)
> print('原列表:',lst)
> 
> lst2=['banana','apple','Cat','Orange']
> print('原列表:',lst2)
> 
> # 忽略大小写进行排序
> new_lst2=sorted(lst2,key=str.lower)
> print('原列表:',lst2)
> print('排序后的列表:',new_lst2)
> ```
> 输出：
> ```
> 原列表: [4, 56, 3, 78, 40, 56, 89]
> 升序: [3, 4, 40, 56, 56, 78, 89]
> 原列表: [4, 56, 3, 78, 40, 56, 89]
> 降序: [89, 78, 56, 56, 40, 4, 3]
> 原列表: [4, 56, 3, 78, 40, 56, 89]
> 原列表: ['banana', 'apple', 'Cat', 'Orange']
> 原列表: ['banana', 'apple', 'Cat', 'Orange']
> 排序后的列表: ['apple', 'banana', 'Cat', 'Orange']
> ```
### （4）列表生成式
**列表生成式的语法结构：**
```python
lst=[expression for item in range]
```
```python
lst=[expression for item in range if condition]
```
> [!举例]-
> ```python
> import random  
> lst=[item for item in range(1,11)]  
> print(lst)  
> 
> lst=[item*item for item in range(1,11)]  
> print(lst)  
> 
> lst=[random.randint(1,100) for _ in range(10)]  
> print(lst)  
> 
> # 从列表中选择符合条件的元素组成新的列表  
> lst=[i for i in range(10) if i%2==0]  
> print(lst)
> ```
> 输出：
> ```
> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
> [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
> [71, 67, 97, 63, 14, 14, 82, 24, 27, 59]
> [0, 2, 4, 6, 8]
> ```

### （5）二维列表的遍历
**语法结构：**
```python
for row in 二维列表:
	for item in row:
		pass
```
**二维列表:表格数据**
![5-6二维列表](/img/user/Extras/Media/5-6二维列表.png)
示例：
```python
# 创建二维列表
lst=[
    ['城市','环比','同比'],
    ['北京',102,103],
    ['上海',104,504],
    ['深圳',100,39]
]
print(lst)

# 遍历二维列表使用双层for循环
for row in lst: # 行
    for item in row: # 列
        print(item,end='\t')
    print() # 换行


# 列表生成式生成一个4行5列的二维列表
lst2=[[j for j in range(5)] for i in range(4)]
print(lst2)
```
输出：
```
[['城市', '环比', '同比'], ['北京', 102, 103], ['上海', 104, 504], ['深圳', 100, 39]]
城市 环比 同比	
北京 102 103	
上海 104 504	
深圳 100 39	
[[0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4]]
```
# 三、元组类型
1. 是Python中内置的**不可变序列**
2. 在Python中使用()定义元组，元素与元素之间使用**英文的逗号**分隔
3. <font color=blue>元组中**只有一个**元素的时候，逗号也不能省略</font>

元组中**只有一个**元素的时候，逗号也不能省略：
```python
# 如果元组中只有一个元素
t=(10)
print(t,type(t))

# 如果元组中只有一个元素，逗号不能省
t=(10,)
print(t,type(t))
```
输出：
```
10 <class 'int'>
(10,) <class 'tuple'>
```

## 1.元组的创建方式
元组的创建方式有两种：
### （1）使用()直接创建元组
**语法结构如下：**
```python
元组名=(element1,element2,.....elementN)
```
### （2）使用内置函数tuple()创建元组
**语法结构如下：**
```python
元组名=tuple(序列)
```
## 2.删除元组
**语法结构如下：**
```python
del 元组名
```
## 3.元组的访问与遍历
> [!举例]-
> ```python
> t=('python','hello','world')
> # 根据索引访问元素
> print(t[0])
> t2=t[0:3:2] # 元组支持切片操作
> print(t2)
> 
> # 元组的遍历
> for item in t:
>     print(item)
> 
> # for+range()+len()
> for i in range(len(t)):
>     print(i,t[i])
> 
> # 使用enumerate()
> for index,item in enumerate(t):
>     print(index,'---->',item)
> 
> for index,item in enumerate(t,start=11): # 序号从11开始
>     print(index,'---->',item)
> ```
> 输出：
> ```
> python
> ('python', 'world')
> python
> hello
> world
> 0 python
> 1 hello
> 2 world
> 0 ----> python
> 1 ----> hello
> 2 ----> world
> 11 ----> python
> 12 ----> hello
> 13 ----> world
> ```
## 4.元组生成式
元组有生成式，不过它的生成式的结果是一个生成器对象，它需要转化成元组或者列表才能看到内容
```python
t=(i for i in range(1,4))
print(t) # 它的生成式的结果是一个生成器对象，它需要转化成元组或者列表才能看到内容
t=tuple(t)
print(t)
# 遍历
for item in t:
    print(item)
```
输出：
```
<generator object <genexpr> at 0x000001E607366080>
(1, 2, 3)
1
2
3
```
## 5.\_\_next\_\_方法
想要看生成式对象，除了使用for循环外，还可以使用\_\_next\_\_方法
```python
t=(i for i in range(1,4))
print(t.__next__())
print(t.__next__())
print(t.__next__())

t=tuple(t)
print(t) # 因为使用__next__()的方法已经把生成器当中的所有元素取出来了，这个时候里面已经没有元素了，没有元素再转成元组类型的时候就什么都没有了
```
输出：
```
1
2
3
()
```
## 6.元组和列表的区别：
|元组|列表|
|:-:|:-:|
|不可变序列|可变序列|
|无法实现添加、删除和修改元素等操作|append()、insert()、remove()、pop()等方法实现添加和删除列表元素|
|支持切片访问元素，不支持修改操作|支持切片访问和修改列表中的元素|
|访问和处理速度快|访问和处理速度慢|
|可以作为字典的键|不能作为字典的键|
# 四、字典类型
1. **字典类型**是根据一个信息查找另一个信息的方式构成了“**键值对**”，它表示索引用的键和对应的值构成的成对关系
2. 字典也是Python当中的**可变数据类型**
3. 与列表不同的是，字典当中的元素是**无序**的，因为它的底层使用了一个叫做hash的东西，如第一个添加到字典中的元素，在内存当中它并不一定是在第一位的。
4. 字典当中**键要求必须唯一**，只能有一个，不能有重复，但是**值可以出现重复**
5. 字典当中的**键要求是不可变序列**，所以字符串、整数、浮点数、元组可以作为字典当中的键，但是列表是不允许作为字典当中的键的
6. 字典也是序列当中的一种，所以序列的相关操作对于字典依然可以使用，字典的删除与列表和元组的删除完全相同，都可以使用`del`语句去删除

<font color=red>**注意事项：**</font>
字典中的key是无序的，Python3.5及其之前的版本字典的key在输出时无序，但是从Python3.6版本之后Python解释器进行了处理，所以才会看到输出的顺序与添加的顺序“—致”
![5-7字典类型](/img/user/Extras/Media/5-7字典类型.png)
## 1.字典的创建方式
字典创建方式有两种：
### （1）使用{}直接创建字典
第一种使用{}直接创建字典
```python
d={key1:value1,key2:value2......}
```
### （2）使用内置函数dict()创建字典
第二种使用内置函数dict()创建字典
#### ①通过映射函数zip创建字典
**语法结构：**
```python
zip(lst1,lst2)
```
![5-8字典的创建方式：使用内置函数dict()创建字典](../../../../Extras/Media/5-8字典的创建方式：使用内置函数dict()创建字典.png)
#### ②直接使用dict()去创建
**语法结构如下：**
```python
dict(key1=value1,key2=value2......)
```
### 举例：
```python
# （1）创建字典
d={10:'cat',20:'dog',30:'pet',20:'zoo'}
print(d) # key相同时，value进行了覆盖

# （2）zip函数
lst1=[10,20,30,40]
lst2=['cat','dog','pet','zoo','car']
zipobj=zip(lst1,lst2)
print(zipobj) # <zip object at 0x000001A940B4E680>
#print(list(zipobj)) # [(10, 'cat'), (20, 'dog'), (30, 'pet'), (40, 'zoo')]
d=dict(zipobj)
print(d) # {10: 'cat', 20: 'dog', 30: 'pet', 40: 'zoo'}

# 使用参数创建字典
d=dict(cat=10,dog=20) # 左侧cat是key，右侧的是value
print(d)
```
输出：
```
{10: 'cat', 20: 'zoo', 30: 'pet'}
<zip object at 0x0000020C568BFD40>
{10: 'cat', 20: 'dog', 30: 'pet', 40: 'zoo'}
{'cat': 10, 'dog': 20}
```
## 2.字典的删除
```python
del 字典名
```
## 3.字典元素的取值
**字典元素的取值：**（其中d是字典对象的名称）
```python
d[key]
```
或者
```pyhton
d.get(key)
```

<br>

举例：
```python
d={'hello':10,'world':20,'python':30}  
# 访问字典当中的元素  
# （1）使用d[key]  
print(d['hello'])  
# （2）d.get(key)  
print(d.get('hello'))  
  
# 两者之间是有区别的，如果key不存在，d[key]报错，d.get(key)可以指定默认值  
# print(d['java']) # KeyError: 'java'  
print(d.get('java')) # None  
print(d.get('java','不存在'))
```
输出：
```
10
10
None
不存在
```
## 4.字典元素的遍历
### （1）遍历出key与value的元组
```python
for element in d.items():
	pass
```
### （2）分别遍历出key和value
```python
for key,value in d.items():
	pass
```
## 5.字典的相关操作方法
|字典的方法|描述说明|
|:-:|:-:|
|d.keys()|获取所有的key数据|
|d.values()|获取所有的value数据|
|d.pop(key,default)|key存在获取相应的value，同时删除key-value对，否则获取默认值|
|d.popitem()|随机从字典中取出一个key-value对，结果为元组类型，同时将该key-value从字典中删除|
|d.clear()|清空字典中所有的key-value对|

举例：
```python
d={1001:'李梅',1002:'王华',1003:'张峰'}
print(d)

# 向字典中添加元素
d[1004]='张丽丽' # 直接使用赋值运算符向字典中添加元素
print(d)

# 获取字典当中所有的key
keys=d.keys()
print(keys) # dict_keys([1001, 1002, 1003, 1004])
print(list(keys))
print(tuple(keys))

# 获取字典当中所有的value
values=d.values()
print(values) # dict_values(['李梅', '王华', '张峰', '张丽丽'])
print(list(values))
print(tuple(values))

# 如果将字典中的数据转成keys-values的形式，以元组的方式进行展现
lst=list(d.items())
print(lst)


d=dict(lst)
print(d)

# 使用pop函数
print(d.pop(1001))
print(d)

print(d.pop(1008,'不存在'))


# 随机删除
print(d.popitem())
print(d)


# 清空字典中所有的元素
d.clear()
print(d)
# Python当中一切皆对象，每个对象都有一个布尔值
print(bool(d)) # 空字典的布尔值为False
```
输出：
```
{1001: '李梅', 1002: '王华', 1003: '张峰'}
{1001: '李梅', 1002: '王华', 1003: '张峰', 1004: '张丽丽'}
dict_keys([1001, 1002, 1003, 1004])
[1001, 1002, 1003, 1004]
(1001, 1002, 1003, 1004)
dict_values(['李梅', '王华', '张峰', '张丽丽'])
['李梅', '王华', '张峰', '张丽丽']
('李梅', '王华', '张峰', '张丽丽')
[(1001, '李梅'), (1002, '王华'), (1003, '张峰'), (1004, '张丽丽')]
{1001: '李梅', 1002: '王华', 1003: '张峰', 1004: '张丽丽'}
李梅
{1002: '王华', 1003: '张峰', 1004: '张丽丽'}
不存在
(1004, '张丽丽')
{1002: '王华', 1003: '张峰'}
{}
False
```
## 6.字典生成式
```python
d={key:value for item in range}
```
```python
d={key:value for key,value in zip(lst1,lst2)}
```
> [!举例]-
> ```python
> import random
> d={item:random.randint(1,100) for item in range(4)}
> print(d)
> 
> # 创建两个列表
> lst=[1001,1002,1003]
> lst2=['陈梅梅','王一一','李丽丽']
> d={key:value for key,value in zip(lst,lst2)}
> print(d)
> ```
> 输出：
> ```
> {0: 76, 1: 49, 2: 35, 3: 2}
> {1001: '陈梅梅', 1002: '王一一', 1003: '李丽丽'}
> ```
# 五、集合类型
1. Python中的集合与数学中集合的概念一致
2. Python中的集合是一个**无序的不重复**元素序列
3. 集合中**只能存储不可变数据类型**，也就是说集合当中可以存储字符串、整数、浮点数、元组，但是它不能存储字典、列表
4. 在Python中集合使用{}定义，元素之间使用**英文的逗号**进行分隔
5. 与列表、字典一样，都是Python中的可变数据类型
## 1.集合的创建方式
集合的创建方式有两种：
### （1）使用{}直接创建集合
**语法结构如下：**
```python
s={element1,element2,......elementN}
```
### （2）使用内置函数set()创建集合
**语法结构如下：**
```python
s=set(可迭代对象)
```
### 举例：
```python
# {}直接创建集合
s={10,20,30,40}
print(s)
# 集合只能存储不可变数据类型
# s={[10,20],[30,40]} # TypeError: unhashable type: 'list'
# print(s)

# 使用set()创建集合
s=set() # 创建了一个空集合，空集合的布尔值是False
print(s)
s={} # 创建的是集合还是字典呢？
print(s,type(s)) # {} <class 'dict'>

s=set('helloworld')
print(s)

s2=set([10,20,30])
print(s2)

s3=set(range(1,10))
print(s3)
```
输出：
```
{40, 10, 20, 30}
set()
{} <class 'dict'>
{'o', 'e', 'd', 'l', 'r', 'h', 'w'}
{10, 20, 30}
{1, 2, 3, 4, 5, 6, 7, 8, 9}
```
## 2.集合的删除
**语法结构如下：**
```python
del 集合名
```
## 3.集合类型的操作符
|操作符|描述说明|
|:-:|:-:|
|A&B|交集|
|A\|B|并集|
|A-B|差集|
|A^B|补集|
![5-9集合类型的操作符](/img/user/Extras/Media/5-9集合类型的操作符.png)
## 4.集合的相关操作方法
|集合的方法|描述说明|
|:-:|:-:|
|s.add(x)|如果x不在集合s中，则将x添加到集合s|
|s.remove(x)|如果x在集合中，将其删除，如果不在集合中，程序报错|
|s.clear()|清除集合中所有元素|
## 5.集合的遍历
```python
s={10,100,30}
for item in s:
    print(item)

# 使用enumerate()函数
for index,item in enumerate(s): # 这里index是序号，而不是索引
    print(index,'-->',item)
```
输出：
```
100
10
30
0 --> 100
1 --> 10
2 --> 30
```
## 6.集合生成式
```python
s={i for i in range(1,10)}
print(s)

s={i for i in range(1,10) if i%2==1}
print(s)
```
输出：
```
{1, 2, 3, 4, 5, 6, 7, 8, 9}
{1, 3, 5, 7, 9}
```
# 六、列表、元组、字典、集合的区别
|数据类型|序列类型|元素是否可重复|是否有序|定义符号|
|:-:|:-:|:-:|:-:|:-:|
|列表list|可变序列|可重复|有序|[]|
|元组tuple|不可变序列|可重复|有序|()|
|字典dict|可变序列|Key不可重复，Value可重复|无序|{key:value}|
|集合set|可变序列|不可重复|无序|{}|
# 七、Python3.11新特性
## 1.结构模型匹配
**语法结构如下：**
```python
match data:
	case {}:
		pass
	case []:
		pass
	case ():
		pass
	case _: # 相当于多重if中的else
		pass
```
## 2.字典合并运算符|
> [!举例]-
> ```python
> d1={'a':10,'b':20}
> d2={'c':30,'d':40,'e':50}
> merged_dict=d1|d2
> print(merged_dict)
> ```
> 输出：
> ```
> {'a': 10, 'b': 20, 'c': 30, 'd': 40, 'e': 50}
> ```
## 3.同步迭代
**语法结构如下：**
```python
match data1,data2:
	case data1,data2:
		pass
```
> [!举例]-
> ```python
> fruits=['apple','orange','pear','grape']  
> counts=[10,3,4,5]  
> for f,c in zip(fruits,counts):
> 	match f,c:
> 		case 'apple',10:
> 			print('10个苹果')
> 		case 'orange',3:
> 			print('3个桔子')
> 		case 'pear',4:
> 			print('4个梨')
> 		case 'grape',5:
> 			print('5串葡萄')
> ```
> 输出：
> ```
> 10个苹果
> 3个桔子
> 4个梨
> 5串葡萄
> ```
> （如果fruits使用的是集合，则输出的则不一样，因为集合是无序的。）

# 章节习题
1. 下面代码的输出结果是：（  ）
```python
d={'a':10,'b':20,'c':30,'d':40}
d2=d
d['b']=100
print(d['b']+d2['b'])
```
A.120
B.40
C.200
D.20

> [!答案]-
> 答案：C
> 解析：
> d是一个字典，然后紧接着把d去赋值给d2了，现在d2和d他们**指向的是同一块内存空间**，当把b的值修改成100的时候，d2看到的也是100，所以两个100相加结果是200，所以答案是C。

2. 以下创建字典的方式错误的是：（  ）
A.d={1:[20,30],3:[30,40]}
B.d={(10,20):1,(30,40):4}
C.d={'张三':30','李四':50}
D.d={[10,20]:张三',[30,40]:'李四'}

> [!答案]-
> 答案：D
> 解析：
> 字典当中的**键要求是不可变序列**，所以字符串、整数、浮点数、元组可以作为字典当中的键，但是列表是不允许作为字典当中的键的

3. 下面代码的输出结果是：
```python
lst=[2008,2022]
lst.append(2035)
lst.append(['2025',2025])
print(lst)
```
A.[2008,2022,2035,'2025',2025]
B.[2008,2022,2035,['2025',2025]]
C.[2008,2022,2025,2035,'2025'
D.[2008,2022,2025,2035,['2025']]

> [!答案]-
> 答案：B
> 解析：
> ['2025',2025]是整体去作为一个元素添加进来的，所以选B。

4. 下面代码的输出结果是：（  ）
```python
lst=[1,3,5,7,9]
print(lst.reverse())
```
A.[9,7,5,3,1]
B.[1,3,5,7,9]
C.None
D.[1,3,5,7,9,]
> [!答案]-
> 答案：C
> 解析：
> 这是一个列表[1,3,5,7,9]，然后使用列表的reverse进行了一个反向，进行反向之后它的结果应该是[9,7,5,3,1]，<font color=red>但是</font>reverse()它的**这个方法是没有返回值的**，所以它输出的结果是**None**，所以选C。

5. 下面代码的输出结果是：（  ）
```python
t=(10)
print(type(t))
```
A.<class 'int'>
B.<class 'tuple'>
C.<class 'list'>
D.<class 'set'>
> [!答案]-
> 答案：A
> 解析：
> 这是一个元组，元组当中只有一个元素，但是他又**没有写逗号**，所以t的数据类型是A，是整数类型，如果后面加一个逗号就是元组类型了。

实战一：
```python
# 创建一个空集合
s=set()
# 录入5位好友的姓名和手机号
for i in range(1,6):
    info=input(f'请输入第{i}位好友的姓名和手机号:')
    # 添加到集合中
    s.add(info)
# 遍历集合
for item in s:
    print(item)
```
其中的新知识点：
```python
info=input(f'请输入第{i}位好友的姓名和手机号:')
```
***
# 参考文献
[1] 杨淑娟.花了2万多买的Python教程全套，现在分享给大家，入门到精通(Python全栈开发教程)\_哔哩哔哩\_bilibili\[EB/OL\].\[2025-09-14\].[花了2万多买的Python教程全套，现在分享给大家，入门到精通(Python全栈开发教程)_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1wD4y1o7AS/)