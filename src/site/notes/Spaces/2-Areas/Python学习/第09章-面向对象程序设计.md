---
{"dg-publish":true,"permalink":"/Spaces/2-Areas/Python学习/第09章-面向对象程序设计/"}
---

# 一、两大编程思想
![9-1两大编程思想](/img/user/Extras/Media/9-1两大编程思想.png)
面向过程和面向对象这两大编程思想，它们是相辅相成的。

面向过程与面向对象的异同点：
- 区别
	- 面向过程：事物比较简单，可以用线性的思维去解决时使用面向过程
	- 面向对象：事物比较复杂，使用简单的线性思维无法解决时使用面向对象
- 共同点
	1. 面向过程和面向对象都是解决实际问题的一种思维方式
	2. 二者相辅相成，并不是对立的
	解决复杂问题，通过面向对象方式便于我们从宏观上把握事物之间复杂的关系，方便我们分析整个系统，具体到微观操作，仍然使用面向过程方式来处理
# 二、类和对象
## 1.类是怎么来的？
类是由N多个对象抽取出“**像**”的**属性**和**行为**从而归纳总结出来的一种**类别**

在Python当中一切皆**对象**
![9-2在Python当中一切皆对象](/img/user/Extras/Media/9-2在Python当中一切皆对象.png)
**自定义数据类型的语法结构为**：
```python
class 类名():
	pass
```
**注**：
1. 上述语法结构中的小括号可写可省略
2. 类名采用单词首字母大写形式(Pascal风格)。例如：MyClass
3. 类相当于图纸，也就是说类是抽象的一个模板，只有创建对象之后才能使用
4. 类是模板，对象是具体的实例，根据这个模板可以创造出具体的实例

**创建对象的语法格式为**：
```python
对象名=类名()
```
## 2.类的组成
![9-3类的组成](/img/user/Extras/Media/9-3类的组成.png)
举例：
```python
class Student:
    # 类属性：定义在类当中，方法外的变量
    school='北京XXX教育'

    # 初始化方法
    def __init__(self,xm,age): # xm,age是方法的参数，是局部变量，xm,age的作用域是整个__init__方法
        self.name=xm # =左侧是实例属性，xm是局部变量，将局部变量的值xm赋值给实例属性self.name
        self.age=age # 实例属性的名称和局部变量的名称可以相同

    # 定义在类中的函数，称为方法，自带一个参数self
    def show(self):
        print(f'我叫:{self.name}，今年:{self.age}岁了')

    # 静态方法
    @staticmethod
    def sm():
        # print(self.name)
        # self.show()
        print('这是一个静态方法，不能调用实例属性，也不能调用实例方法')

    @classmethod
    def cm(cls): # cls-->class的简写
        # print(self.name)
        # self.show()
        print('这是一个类方法，不能调用实例属性，也不能调用实例方法')

# 创建类的对象
stu=Student('ysj',18) # 为什么会传了两个参数，因为__init__方法中，有两个形参，self是自带的参数，无需手动传入
# 实例属性，使用对象名进行打点调用的
print(stu.name,stu.age)
# 类属性，直接使用类名，打点调用
print(Student.school)
# 实例方法，使用对象名进行打点调用
stu.show()
# 类方法，@classmethod进行修饰的方法，直接使用类名打点调用
Student.cm()
# 静态方法，@staticmethod进行修饰的方法，直接使用类名打点调用
Student.sm()
```
输出：
```
ysj 18
北京XXX教育
我叫:ysj，今年:18岁了
这是一个类方法，不能调用实例属性，也不能调用实例方法
这是一个静态方法，不能调用实例属性，也不能调用实例方法
```
**注意**：类方法、类属性、静态方法都是使用类名去调用的；跟实例有关的，都是使用对象名去进行打点调用的。
<br><br>
需求：要求编写一个学生类创建四个学生对象，将这4个学生对象存储到列表当中，最后遍历列表并调用学生对象的方法

答案：
```python
class Student:
    # 类属性：定义在类当中，方法外的变量
    school='北京XXX教育'

    # 初始化方法
    def __init__(self,xm,age): # xm,age是方法的参数，是局部变量，xm,age的作用域是整个__init__方法
        self.name=xm # =左侧是实例属性，xm是局部变量，将局部变量的值xm赋值给实例属性self.name
        self.age=age # 实例属性的名称和局部变量的名称可以相同

    # 定义在类中的函数，称为方法，自带一个参数self
    def show(self):
        print(f'我叫:{self.name}，今年:{self.age}岁了')

# 根据“图纸”可以创建出N多个对象
stu=Student('ysj',18)
stu2=Student('陈梅梅',20)
stu3=Student('马丽',21)
stu4=Student('Marry',23) # 等号右侧都是Student

print(type(stu))
print(type(stu2))
print(type(stu3))
print(type(stu4))

Student.school='派森教育' # 给类的类属性赋值

# 将学生对象存储到列表中
lst=[stu,stu2,stu3,stu4] # 列表中的元素是Student类型的对象
for item in lst: # item是列表中的元素，是Student类型的对象
    item.show() # 对象名打点调用实例方法
```
输出：
```
<class '__main__.Student'>
<class '__main__.Student'>
<class '__main__.Student'>
<class '__main__.Student'>
我叫:ysj，今年:18岁了
我叫:陈梅梅，今年:20岁了
我叫:马丽，今年:21岁了
我叫:Marry，今年:23岁了
```
## 3.动态绑定属性和方法
每个对象的**属性名称相同**，但**属性值不同**
可以为某个对象绑定**独有**的**属性**或**方法**
```python
class Student:
    # 类属性：定义在类当中，方法外的变量
    school='北京XXX教育'

    # 初始化方法
    def __init__(self,xm,age): # xm,age是方法的参数，是局部变量，xm,age的作用域是整个__init__方法
        self.name=xm # =左侧是实例属性，xm是局部变量，将局部变量的值xm赋值给实例属性self.name
        self.age=age # 实例属性的名称和局部变量的名称可以相同

    # 定义在类中的函数，称为方法，自带一个参数self
    def show(self):
        print(f'我叫:{self.name}，今年:{self.age}岁了')

# 创建两个Student类型的对象
stu=Student('ysj',18)
stu2=Student('陈梅梅',20)
print(stu.name,stu.age)
print(stu2.name,stu2.age)

# 为stu2动态绑定一个实例属性
stu2.gender='男'
print(stu2.name,stu2.age,stu2.gender)

# print(stu.gender) # AttributeError: 'Student' object has no attribute 'gender'

# 动态绑定方法
def introduce():
    print('我是一个普通的函数，我被动态绑定成了stu2对象的方法')
stu2.fun=introduce # 函数的一个赋值，（不要加小括号）
# fun就是stu2对象的方法了
# 调用
stu2.fun()
```
输出：
```
ysj 18
陈梅梅 20
陈梅梅 20 男
我是一个普通的函数，我被动态绑定成了stu2对象的方法
```
# 二、面向对象的三大特征
1. **封装**：隐藏内部细节，对外提供操作方式
2. **继承**：是在函数调用时，使用“形参名称=值”的方式进行传参，传递参数顺序可以与定义时参数的顺序不同
3. **多态**：是在函数定义时，直接对形式参数进行赋值，在调用时如果该参数不传值，将使用默认值，如果该参数传值，则使用传递的值
## 1.封装-权限控制
**权限控制**是通过对属性或方法添加单下划线、双下划线以及首尾双下划线来实现
1. **单下划线开头**：以单下划线开头的属性或方法表示protected受保护的成员，这类成员被视为仅供内部使用，允许类本身和子类进行访问，但实际上它可以被外部代码访问。
2. **双下划线开头**：表示private私有的成员，这类成员只允许定义该属性或方法的类本身进行访问
3. **首尾双下划线**：一般表示特殊的方法

作用：保护程序的安全

举例：
```python
class Student():
    # 首尾双下划线
    def __init__(self,name,age,gender):
        self._name=name # self._name受保护的，只能本类和子类访问
        self.__age=age # self.__age表示私有的，只能类本身去访问
        self.gender=gender # 普通的实例属性，类的内部，外部，及子类都可以访问

    def _fun1(self): # 受保护的
        print('子类及本身可以访问')

    def __fun2(self): # 私有的
        print('只有类本身可以访问')

    def fun3(self): # 普通的实例方法
        self._fun1() # 类本身访问受保护的方法
        self.__fun2() # 类本身访问私有方法
        print(self._name) # 受保护的实例属性
        print(self.__age) # 私有的实例属性

# 创建一个学生类的对象
stu=Student('陈梅梅',20,'女')
# 类的外部
print(stu._name)
# print(stu.__age) # AttributeError: 'Student' object has no attribute '__age'. Did you mean: '_name'?

# 调用受保护的实例方法
stu._fun1() # 子类及本身可以访问
# 私有方法
# stu.__fun2() # AttributeError: 'Student' object has no attribute '__fun2'. Did you mean: '_fun1'?

# 私有的实例属性和方法是真的不能访问吗？
print(stu._Student__age) # 为什么可以这样访问呢？
stu._Student__fun2()

print(dir(stu)) # dir()可以展示出这个对象的所有属性和方法，在它展示出来的这个属性和方法当中，私有的__age是它定义为_Student__age，所以这是我们的访问的形式，__fun2同理
```
输出：
```
陈梅梅
子类及本身可以访问
20
只有类本身可以访问
['_Student__age', '_Student__fun2', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__firstlineno__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__static_attributes__', '__str__', '__subclasshook__', '__weakref__', '_fun1', '_name', 'fun3', 'gender']
```
**注意**：在上述例子当中，我们使用`stu._Student__age`这样去访问它的私有属性，实际上这种方法是非常不推荐的，我们在编写程序的过程当中，我们可以使用一个装饰器，装饰器是Python当中的一个名词（概念），它是使用@符号去开头的，我们可以使用`@property`将一个方法去转换成属性去使用，就是说它的定义形式是方法，但是在使用的时候是不需要加括号的，就把它当属性使就可以了，那么使用这个`@property`去修饰方法就可以将其转换成属性了，那么我们在访问的时候只能访问属性的值却无法修改值，就是只能让你看而不能改，那么如果想改怎么办？如果你想改的话就需要再去设置一个setter， 就是设置的（setter）这样的一个方法才能够去修改属性值。

举例：
```python
class Student:
    def __init__(self,name,gender):
        self.name=name
        self.__gender=gender # self.__gender是私有的实例属性

    # 使用@property修饰方法，将方法转成属性使用
    @property
    def gender(self):
        return self.__gender

    # 将我们的gender这个属性设置为可写属性
    @gender.setter
    def gender(self,value):
        if value!='男' and value!='女':
            print('性别有误，已将性别默认设置为男')
            self.__gender='男'
        else:
            self.__gender=value

stu=Student('陈梅梅','女')
print(stu.name,'的性别是:',stu.gender) # stu.gender就会去执行stu.gender()

stu.gender='其它'
print(stu.name,'的性别是:',stu.gender)
```
输出：
```
陈梅梅 的性别是: 女
性别有误，已将性别默认设置为男
陈梅梅 的性别是: 男
```
## 2.继承
在程序设计中，被继承的类称为父类或者是基类，新的类称为子类或者是派生类。子类继承了父类，就拥有了父类所有公有成员和受保护的成员。
1. 在Python中一个子类可以继承N多个父类
2. 一个父类也可以拥有N多个子类
3. 如果一个类没有继承任何类，那么这个类默认继承的是object类

之前说类名的后面小括号可以不写，那是在没有继承的情况下，或者说是默认继承object的情况下小括号是可以省略不写的。现在继承中在这个类名后面的小括号当中放的是它的父类

**继承的语法结构**：
```python
class 类名(父类1,父类2...,父类N):
	pass
```
举例：
```python
class Person: # 默认继承了object
    def __init__(self,name,age):
        self.name=name
        self.age=age
    def show(self):
        print(f'大家好，我叫:{self.name}，我今年:{self.age}岁')

# Student继承Person类
class Student(Person):
    # 编写初始化的方法
    def __init__(self,name,age,stuno):
        super().__init__(name,age) # 调用父类的初始化方法，为name和age赋值
        self.stuno=stuno

# Doctor继承了Person类
class Doctor(Person):
    # 编写初始化的方法
    def __init__(self,name,age,department):
        super().__init__(name,age)
        self.department=department

# 创建第一个子类对象
stu=Student('陈梅梅',20,'1001')
stu.show()

doctor=Doctor('张一一',32,'外科')
doctor.show()
```
输出：
```
大家好，我叫:陈梅梅，我今年:20岁
大家好，我叫:张一一，我今年:32岁
```
### Python中的多继承
```python
class FatherA():
    def __init__(self,name):
        self.name=name

    def showA(self):
        print('父类A中的方法')

class FatherB():
    def __init__(self,age):
        self.age=age

    def showB(self):
        print('父类B中的方法')
# 多继承
class Son(FatherA,FatherB):
    def __init__(self,name,age,gender):
        # 需要调用两个父类的初始化方法
        FatherA.__init__(self,name)
        FatherB.__init__(self,age)
        self.gender=gender

son=Son('陈梅梅',20,'女') # 调用Son类中的__init__执行
son.showA()
son.showB()
```
输出：
```
父类A中的方法
父类B中的方法
```
### 方法重写
1. 子类继承了父类就拥有了父类中公有成员和受保护的成员
2. 父类的方法并不能完全适合子类的需求的时候，子类就可以重写父类的方法
3. 子类在重新父类的方法时，要求方法的名称必须与父类方法的名称相同，在子类重写后的方法中可以通过super().xxx()调用父类中的方法

举例：
```python
class Person: # 默认继承了object
    def __init__(self,name,age):
        self.name=name
        self.age=age
    def show(self):
        print(f'大家好，我叫:{self.name}，我今年:{self.age}岁')

# Student继承Person类
class Student(Person):
    # 编写初始化的方法
    def __init__(self,name,age,stuno):
        super().__init__(name,age) # 调用父类的初始化方法，为name和age赋值
        self.stuno=stuno

    def show(self):
        # 调用父类中的方法
        super().show()
        print(f'我来自XXX大学，我的学号是{self.stuno}')

# Doctor继承了Person类
class Doctor(Person):
    # 编写初始化的方法
    def __init__(self,name,age,department):
        super().__init__(name,age)
        self.department=department

    def show(self):
        # super().show() # 调用父类中show方法
        print(f'大家好，我叫:{self.name}，我今年{self.age}岁，我的工作科室是:{self.department}')

# 创建第一个子类对象
stu=Student('陈梅梅',20,'1001')
stu.show() # 调用子类自己的show方法

doctor=Doctor('张一一',32,'外科')
doctor.show() # 调用子类自己的show()方法
```
输出：
```
大家好，我叫:陈梅梅，我今年:20岁
我来自XXX大学，我的学号是1001
大家好，我叫:张一一，我今年32岁，我的工作科室是:外科
```
## 3.多态
1. 指的就是“**多种形态**”，即便不知道一个变量所引用的对象到底是什么类型，仍然可以通过这个变量调用对象的方法。
2. 在程序运行过程中根据变量所引用对象的数据类型，**动态决定**调用哪个对象中的方法。
3. Python语言中的多态，根本不关心对象的数据类型，也不关心类之间是否存在继承关系，只关心对象的行为（方法）。只要不同的类中有同名的方法，即可实现多态

可以实现程序的可扩展性

举例：
```python
class Person():
    def eat(self):
        print('人，吃五谷杂粮')

class Cat():
    def eat(self):
        print('猫，喜欢吃鱼')

class Dog():
    def eat(self):
        print('狗，喜欢啃骨头')

# 这三个类都有一个同名的方法，eat
# 编写函数
def fun(obj): # obj是函数的形式参数，在定义处知道这个形参的数据类型吗？不知道
    obj.eat() # 通过变量obj（对象）调用eat方法

# 创建三个类的对象
per=Person()
cat=Cat()
dog=Dog()

# 调用fun函数
fun(per) # Python中的多态，不关心对象的数据类型，只关心对象是否具有同名方法
fun(cat)
fun(dog)
```
输出：
```
人，吃五谷杂粮
猫，喜欢吃鱼
狗，喜欢啃骨头
```
# 三、object类
如果一个类没有继承任何类，那么这个类默认继承的是object类
1. 所有类直接或间接的父类
2. 所有类都拥有object类的属性和方法
## 1.特殊方法
|object类中特殊的方法|功能描述|
|:-:|:-:|
|\_\_new\_\_()|由系统调用，用于创建对象|
|\_\_init\_\_()|创建对象时手动调用，用于初始化对象属性值|
|\_\_str\_\_()|对象的描述，返回值是str类型，默认输出对象的内存地址。|

先后顺序是先\_\_new\_\_()系统调用创建对象，然后再去由\_\_init\_\_()去给对象的属性赋值，只不过是创建对象的时候自动去调用的
```python
class Person(object):
    def __init__(self,name,age):
        self.name=name
        self.age=age

    def show(self):
        print(f'大家好，我叫:{self.name}，我今年:{self.age}岁')

# 创建Person类的对象
per=Person('陈梅梅',20) # 创建对象的时候就会自动调用__init__方法（）
print(dir(per))

print(per) # 自动调用了__str__方法
```
输出：
```
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__firstlineno__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__static_attributes__', '__str__', '__subclasshook__', '__weakref__', 'age', 'name', 'show']
<__main__.Person object at 0x0000018E8B626F90>
```
<big>**\_\_str\_\_方法重写**：</big>
重写之前：
```python
class Person(object):
    def __init__(self,name,age):
        self.name=name
        self.age=age

# 创建Person类的对象
per=Person('陈梅梅',20)
print(per)
```
输出：
```
<__main__.Person object at 0x00000162C7F76F90>
```
重写之后：
```python
class Person(object):
    def __init__(self,name,age):
        self.name=name
        self.age=age

    # 方法重写
    def __str__(self):
        return '这是一个人类，具有name和age两个实例属性' # 返回值是一个字符串

# 创建Person类的对象
per=Person('陈梅梅',20)
print(per) # 还是内存地址吗？不是，是__str__方法中的内容  直接输出对象名，实际上是调用__str__方法
print(per.__str__()) # 手动调用
```
输出：
```
这是一个人类，具有name和age两个实例属性
这是一个人类，具有name和age两个实例属性
```

|运算符|特殊方法|功能描述|
|:-:|:-:|:-:|
|+|\_\_add\_\_()|执行加法运算|
|-|\_\_sub\_\_()|执行减法运算|
|<，<=，\=\=|\_\_lt\_\_()，\_\_le\_\_()，\_\_eq\_\_()|执行比较运算|
|>，>=，!=|\_\_gt()，\_\_ge\_\_()，\_\_ne\_\_()|执行比较运算|
|*，/|\_\_mul\_\_()，\_\_truediv\_\_()|执行乘法运算，非整除运算|
|%，//|\_\_mod\_\_()，\_\_floordiv\_\_()|执行取余运算，整除运算|
|**|\_\_pow\_\_()|执行幂运算|
> [!举例]-
> ```python
> a=10
> b=20
> print(dir(a)) # Python中一切皆对象
> print(a+b) # 执行加法运算
> print(a.__add__(b))
> print(a.__sub__(b))
> print(f'{a}<{b}吗？',a.__lt__(b))
> print(f'{a}<={b}吗？',a.__le__(b))
> print(f'{a}=={b}吗？',a.__eq__(b))
> print('-'*40)
> print(f'{a}>{b}吗？',a.__gt__(b))
> print(f'{a}>={b}吗？',a.__ge__(b))
> print(f'{a}!={b}吗？',a.__ne__(b))
> #
> print('-'*40)
> print(a.__mul__(b)) # 乘法
> print(a.__truediv__(b)) # 除法
> print(a.__mod__(b)) # 取余
> print(a.__floordiv__(b)) # 整除
> print(a.__pow__(2))
> ```
> 输出：
> ```
> ['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__getstate__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio', 'bit_count', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'is_integer', 'numerator', 'real', 'to_bytes']
> 30
> 30
> -10
> 10<20吗？ True
> 10<=20吗？ True
> 10==20吗？ False
> ----------------------------------------
> 10>20吗？ False
> 10>=20吗？ False
> 10!=20吗？ True
> ----------------------------------------
> 200
> 0.5
> 10
> 0
> 100
> ```

## 2.特殊属性
在Python当中，首尾双下划线的方法称为特殊方法，那么首尾双下划线所定义的属性就称为特殊属性。

|特殊属性|功能描述|
|:-:|:-:|
|obj.\_\_dict\_\_|对象的属性字典|
|obj.\_\_class\_\_|对象所属的类|
|class.\_\_bases\_\_|类的父类元组|
|class.\_\_base\_\_|类的父类|
|class.\_\_mro\_\_|类的层次结构|
|class.\_\_subclasses\_\_()|类的子类列表|
**注**：
1. 如果继承了N多个父类，\_\_base\_\_的结果只显示第一个父类
2. 如果同时继承了两个父类，继承了FatherA、FatherB，在FatherA和FatherB当中有同名的方法，那么它在调用的时候，默认调用的是第一个父类的方法

> [!举例]-
> ```python
> class A:
>     pass
> class B:
>     pass
> class C(A,B):
>     def __init__(self,name,age):
>         self.name=name
>         self.age=age
> 
> # 创建类的对象
> a=A()
> b=B()
> # 创建C类的对象
> c=C('陈梅梅',20)
> 
> print('对象a的属性字典:',a.__dict__) # 对象的属性字典
> print('对象b的属性字典:',b.__dict__)
> print('对象c的属性字典:',c.__dict__)
> 
> print('对象a所属的类:',a.__class__)
> print('对象b所属的类:',b.__class__)
> print('对象c所属的类:',c.__class__)
> 
> print('A类的父类元组',A.__bases__)
> print('B类的父类元组',B.__bases__)
> print('C类的父类元组',C.__bases__)
> 
> print('A类的父类:',A.__base__)
> print('B类的父类:',B.__base__)
> print('C类的父类:',C.__base__) # A类，如果继承了N多个父类，结果只显示第一个父类
> 
> print('A类的层次结构:',A.__mro__)
> print('B类的层次结构:',B.__mro__)
> print('C类的层次结构:',C.__mro__) # C类继承了A类、B类，间接继承了object类
> 
> # 子类列表
> print('A类的子类列表:',A.__subclasses__()) # A的子类有C类
> print('B类的子类列表:',B.__subclasses__())
> print('C类的子类列表:',C.__subclasses__()) # []列表
> ```
> 输出：
> ```
> 对象a的属性字典: {}
> 对象b的属性字典: {}
> 对象c的属性字典: {'name': '陈梅梅', 'age': 20}
> 对象a所属的类: <class '__main__.A'>
> 对象b所属的类: <class '__main__.B'>
> 对象c所属的类: <class '__main__.C'>
> A类的父类元组 (<class 'object'>,)
> B类的父类元组 (<class 'object'>,)
> C类的父类元组 (<class '__main__.A'>, <class '__main__.B'>)
> A类的父类: <class 'object'>
> B类的父类: <class 'object'>
> C类的父类: <class '__main__.A'>
> A类的层次结构: (<class '__main__.A'>, <class 'object'>)
> B类的层次结构: (<class '__main__.B'>, <class 'object'>)
> C类的层次结构: (<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)
> A类的子类列表: [<class '__main__.C'>]
> B类的子类列表: [<class '__main__.C'>]
> C类的子类列表: []
> ```
# 四、类的深拷贝与浅拷贝
1. **变量的赋值**：只是形成两个变量实际上还是指向**同一个对象**
2. **浅拷贝**：拷贝时，对象包含的**子对象内容不拷贝**，因此，源对象与拷贝对象会引用同一个子对象
3. **深拷贝**：使用copy模块的deepcopy函数，递归拷贝对象中包含的子对象，**源对象和拷贝对象所有的子对象也不相同**

> [!举例]-
> ```python
> class CPU():
>     pass
> class Disk():
>     pass
> class Computer():
>     # 计算机由CPU和硬盘
>     def __init__(self,cpu,disk):
>         self.cpu=cpu
>         self.disk=disk
> 
> cpu=CPU() # 创建了一个cpu对象
> disk=Disk() # 创建了一个硬盘对象
> 
> # 创建一个计算机对象
> com=Computer(cpu,disk)
> # 变量（对象）的赋值
> com1=com
> print(com,'子对象的内存地址:',com.cpu,com.disk)
> print(com1,'子对象的内存地址:',com1.cpu,com1.disk)
> 
> # 类对象的浅拷贝
> print('-'*40)
> import copy
> com2=copy.copy(com) # com2是将产生的对象，com2的子对象,cpu,disk不变
> print(com,'子对象的内存地址:',com.cpu,com.disk)
> print(com2,'子对象的内存地址:',com2.cpu,com2.disk)
> 
> # 类对象的深拷贝
> print('-'*40)
> com3=copy.deepcopy(com) # com3是将产生的对象，com3的子对象,cpu,disk也会重新创建
> print(com,'子对象的内存地址:',com.cpu,com.disk)
> print(com3,'子对象的内存地址:',com3.cpu,com3.disk)
> ```
> 输出：
> ```
> <__main__.Computer object at 0x0000021F6DF07230> 子对象的内存地址: <__main__.CPU object at 0x0000021F6DF06F90> <__main__.Disk object at 0x0000021F6DF070E0>
> <__main__.Computer object at 0x0000021F6DF07230> 子对象的内存地址: <__main__.CPU object at 0x0000021F6DF06F90> <__main__.Disk object at 0x0000021F6DF070E0>
> ----------------------------------------
> <__main__.Computer object at 0x0000021F6DF07230> 子对象的内存地址: <__main__.CPU object at 0x0000021F6DF06F90> <__main__.Disk object at 0x0000021F6DF070E0>
> <__main__.Computer object at 0x0000021F6E0E5A90> 子对象的内存地址: <__main__.CPU object at 0x0000021F6DF06F90> <__main__.Disk object at 0x0000021F6DF070E0>
> ----------------------------------------
> <__main__.Computer object at 0x0000021F6DF07230> 子对象的内存地址: <__main__.CPU object at 0x0000021F6DF06F90> <__main__.Disk object at 0x0000021F6DF070E0>
> <__main__.Computer object at 0x0000021F6E0E5BD0> 子对象的内存地址: <__main__.CPU object at 0x0000021F6E0E5D10> <__main__.Disk object at 0x0000021F6E0E5E50>
> ```
> 图解：（图中的内存地址是上述的内存地址的最后四位数）
> ![](/img/user/Extras/Media/media-第9章-面向对象程序设计-1.png)

# 章节习题
1. 阅读下面代码，程序的运行结果是：（ ）
```python
class MyClass(object):
    def __init__(self,name,age):
        print('name:',name, 'age:',age)

obj=MyClass('陈梅梅',20)
```
A．代码错误
B．name: 陈梅梅 age: 20
C．MyClass
D．'name: 陈梅梅 age: 20'
> [!答案]-
> 答案：B
> 解析：
> 当它去创建对象的时候，会自动调用__init__方法去执行，而__init__方法的方法体是输出一段代码，所以它会输出name: 陈梅梅 age: 20

2. 阅读下面代码，程序的运行结果是：
```python
class Person(object):
    def __init__(self,xm,nl):
        self.name=xm
        self.age=nl
    def show(    ):
        print(f'{self.name}说:我{self.age}岁')

per=Person('陈梅梅',20)
per.show()
```
A．代码错误，show方法中少self
B．陈梅梅说:我20岁
C．应该将self.name修改为self.xm
D．'陈梅梅说:我20岁'
> [!答案]-
> 答案：A

3. 阅读下面代码，程序的运行结果是（ ）
```python
class A:
    def show(self):
        print(1)
class B:
    def show(self):
        print(2)
class C(A,B):
    def show(self):
        print(3)
        
c=C()
c.show()
```
A．1
B．2
C．3
D．123
> [!答案]-
> 答案：C
> 解析：
> 这是方法重写

***
# 参考文献
[1] 杨淑娟.花了2万多买的Python教程全套，现在分享给大家，入门到精通(Python全栈开发教程)\_哔哩哔哩\_bilibili\[EB/OL\].\[2025-09-14\].[花了2万多买的Python教程全套，现在分享给大家，入门到精通(Python全栈开发教程)_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1wD4y1o7AS/)