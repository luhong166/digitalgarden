---
{"dg-publish":true,"dg-path":"Python/第08章-函数及常用的内置函数.md","permalink":"/Python/第08章-函数及常用的内置函数/"}
---

# 一、函数的定义及调用
## 1.函数
**函数**是将一段实现功能的完整代码，使用函数名称进行封装，通过函数名称进行调用。以此达到一次编写，多次调用的目的。
### （1）内置函数
例如：
1. 输出函数print()
2. 输入函数input()
3. 列表定义函数list()
### （2）自定义函数
**自定义函数的语法结构如下：**
```python
def 函数名称（参数列表）:
	函数体
	[return返回值列表] # return返回值列表是非必须的
```
### （3）函数调用
```python
函数名(参数列表)
```
### 举例：
```python
def get_sum(num): # num叫形式参数
    s=0
    for i in range(1,num+1):
        s+=i
    print(f'1到{num}之间的累加和为:{s}')

# 函数的调用
get_sum(10) # 1-10之间的累加和        10是实际参数值
get_sum(100) # 1-100之间的累加和      100是实际参数值
get_sum(1000) # 1-1000之间的累加和    1000是实际参数值
```
输出：
```
1到10之间的累加和为:55
1到100之间的累加和为:5050
1到1000之间的累加和为:500500
```
### 函数的使用总结：
1. 函数定义
	1. 使用关键字def
	2. 确定函数名称、参数名称、参数个数、编写函数体（用于实现函数功能的代码）
2. 函数调用
	1. 通过函数名称进行调用函数
	2. 对函数的个个参数进行实际的赋值
3. 函数执行
	- 使用实际参数参与函数功能的实现
4. 函数返回结果
	- 函数执行结束后，如果使用return进行返回结果，则结果被返回到函数的调用处
## 2.函数的参数传递
### （1）位置参数
**位置参数**是指调用时的参数个数和顺序必须与定义的参数个数和顺序相同。
> [!note]- 举例
> ```python
> def happy_birthday(name,age):
>     print('祝'+name+'生日快乐')
>     print(str(age)+'岁生日快乐')
> 
> # 调用
> # happy_birthday('娟子姐') # TypeError: happy_birthday() missing 1 required positional argument: 'age'
> 
> # happy_birthday(18,'娟子姐') # TypeError: can only concatenate str (not "int") to str
> 
> # 正确的调用方式
> happy_birthday('娟子姐',18)
> ```
> 输出：
> ```
> 祝娟子姐生日快乐
> 18岁生日快乐
> ```
### （2）关键字参数
**关键字参数**是在函数调用时，使用“形参名称=值”的方式进行传参，传递参数顺序可以与定义时参数的顺序不同。在进行参数传递的时候，要求这个名称必须与函数定义的参数名称相同，如果不相同，程序就会报错
> [!note]- 举例
> ```python
> def happy_birthday(name,age):
>     print('祝'+name+'生日快乐')
>     print(str(age)+'岁生日快乐')
> 
> # 关键字传参
> happy_birthday(age=18,name='娟子姐')
> 
> # happy_birthday(age=18,name1='娟子姐') # 定义的形参名称为name，TypeError: happy_birthday() got an unexpected keyword argument 'name1'. Did you mean 'name'?
> 
> happy_birthday('陈梅梅',age=18) # 正常执行， 位置传参，也可以使用关键字传参
> 
> # happy_birthday(name='陈梅梅',18) # SyntaxError: positional argument follows keyword argument
> 
> # 位置传参在前，关键字传参在后
> ```
> 输出：
> ```
> 祝娟子姐生日快乐
> 18岁生日快乐
> 祝陈梅梅生日快乐
> 18岁生日快乐
> ```
### （3）默认值参数
**默认值参数**是在函数定义时，直接对形式参数进行赋值，在调用时如果该参数不传值，将使用默认值，如果该参数传值，则使用传递的值。
**注意**：当同时存在位置参数和默认值参数的时候，应该遵循 位置参数在前，默认值参数在后
> [!note]- 举例
> ```python
> def happy_birthday(name='娟子姐',age=18):
>     print('祝'+name+'生日快乐')
>     print(str(age)+'岁生日快乐')
> 
> # 调用
> happy_birthday() # 不用传参
> happy_birthday('陈梅梅') # 位置传参
> happy_birthday(age=19) # 关键字传参，name采用默认值
> 
> # happy_birthday(19) # 19会被赋值给哪个变量呢，如果使用位置传参的方式，19被传给了name
> 
> # 同时存在位置参数和默认值参数的时候，默认值参数放最后
> def fun(a,b=20): # a作为位置参数，b默认值参数
>     pass
> 
> # def fun2(a=20,b): # 报错了，语法错误    当存在位置参数和默认值参数的时候，位置参数在后会被报错
> #     pass
> 
> # 当存在位置参数和默认值参数的时候，应该遵循 位置参数在前，默认值参数在后
> ```
> 输出：
> ```
> 祝娟子姐生日快乐
> 18岁生日快乐
> 祝陈梅梅生日快乐
> 18岁生日快乐
> 祝娟子姐生日快乐
> 19岁生日快乐
> ```
### （4）可变参数
**可变参数**又分为**个数可变的位置参数**和**个数可变的关键字参数**两种，其中**个数可变的位置参数**是在参数前加**一颗星（\*para）**，para形式参数的名称，函数调用时可接收任意个数的实际参数，并放到一个元组中。**个数可变的关键字参数**是在参数前加**两颗星（\*\*para）**，在函数调用时可接收任意多个“参数=值”形式的参数，并放到一个字典中。

**注意**：在调用时，在参数前加一颗星是对这个列表进行一个系列解包操作；在参数前加两颗星是对这个字典进行一个系列解包操作。

举例：
```python
# 个数可变的位置参数
def fun(*para):
    print(type(para))
    for item in para:
        print(item)

# 调用
fun(10,20,30,40)
fun(10)
fun(20,30)
fun([11,22,33,44]) # 实际上传递的是一个参数
# 在调用时，参数前加一颗星，会将列表进行解包
fun(*[11,22,33,44])

# 个数可变的关键字参数
def fun2(**kwpara):
    print(type(kwpara))
    for key,value in kwpara.items():
        print(key,'-----',value)

# 调用
fun2(name='娟子姐',age=18,height=170) # 关键字参数

d={'name':'娟子姐','age':18,'height':170}
# fun2(d) # 在此不能以字典为参数，TypeError: fun2() takes 0 positional arguments but 1 was given
fun2(**d) # 解列解包操作
```
输出：
```
<class 'tuple'>
10
20
30
40
<class 'tuple'>
10
<class 'tuple'>
20
30
<class 'tuple'>
[11, 22, 33, 44]
<class 'tuple'>
11
22
33
44
<class 'dict'>
name ----- 娟子姐
age ----- 18
height ----- 170
<class 'dict'>
name ----- 娟子姐
age ----- 18
height ----- 170
```
## 3.函数的返回值
1. 如果函数的运行结果需要在其它函数中使用，那么这个函数就应该被定义为带返回值的函数
2. 函数的运行结果使用return关键字进行返回
3. return可以出现在函数中的任意一个位置，用于结束函数
4. 返回值可以是一个值，或多个值，如果返回的值是多个，结果是一个元组类型

举例：
```python
# 函数的返回值
def calc(a,b):
    print(a+b)

calc(10,20)
print(calc(1,2)) # None

def calc2(a,b):
    s=a+b
    return s # 将s返回给函数的调用处去处理

print('-'*10)
get_s=calc2(1,2) # 存储到变量中
print(get_s)

get_s2=calc2(calc2(1,2),3) # 1+2+3 先去执行calc2(1,2) 返回 结果为3，再去执行calc2(3,3)
print(get_s2)

# 返回值可以是多个
def get_sum(num):
    s=0 # 累加和
    odd_sum=0 # 奇数和
    even_sum=0 # 偶数和
    for i in range(1,num+1):
        if i%2!=0: # 说明是奇数
            odd_sum+=i
        else:
            even_sum+=i
        s+=i
    return odd_sum,even_sum,s # 三个值

result=get_sum(10)
print(type(result))
print(result)

# 解包赋值
a,b,c=get_sum(10) # 返回三个值，元组类型
print(a)
print(b)
print(c)
```
输出：
```
30
3
None
----------
3
6
<class 'tuple'>
(25, 30, 55)
25
30
55
```
## 4.变量的作用域
**变量的作用域**是指变量起作用的范围，根据范围作用的大小可分为**局部变量**和**全局变量**
### （1）局部变量
**定义**：在函数定义处的参数和函数内部定义的变量
**作用范围**：仅在函数内部，函数执行结束，局部变量的生命周期也结束
### （2）全局变量
**定义**：在函数外定义的变量或函数内部使用global关键字修饰的变量
**作用范围**：整个程序，程序运行结束，全局变量的生命周期才结束
### 举例：
```python
a=100 # 全局变量

def calc(x,y):
    return a+x+y
print(a)
print(calc(10,20))
print('-'*30)
def calc2(x,y):
    a=200 # 局部变量，局部变量的名称和全局变量的名称相同
    return a+x+y # a是全局变量还是局部变量呢？   局部变量，当全局变量和局部变量的名称相同时，局部变量的优先级高

print(calc2(10,20)) # 230
print(a) # 100
print('-'*30)

def calc3(x,y):
    global s # s在函数中定义的变量，但是使用了global关键字声明，这个变量s变成了全局变量
    s=300 # 声明和赋值，必须是分开执行，放在一行是不可以的
    return s+x+y

print(calc3(10,20)) # 330
print(s)
```
输出：
```
100
130
------------------------------
230
100
------------------------------
330
300
```
## 5.匿名函数lambda
**匿名函数lambda**是指没有名字的函数，这种函数只能使用一次，一般是在函数的函数体只有一句代码且只有一个返回值时，可以使用匿名函数来简化

**语法结构**：
```python
result=lambda 参数列表:表达式
```
举例：
```python
def calc(a,b):
    return a+b
print(calc(10,20))

# 匿名函数
s=lambda a,b:a+b # s表示就是一个匿名函数
print(type(s)) # <class 'function'>
# 调用匿名函数
print(s(10,20))
print('-'*30)
# 列表的正常取值操作
lst=[10,20,30,40,50]
for i in range(len(lst)):
    print(lst[i])
print('-'*30)

for i in range(len(lst)):
    result=lambda x:x[i] # 根据索引取值，result的类型是function，x是实际参数
    print(result(lst)) # lst是实际参数


student_scores=[
    {'name': '陈梅梅', 'score': 98},
    {'name': '王一一', 'score': 95},
    {'name': '张天乐', 'score': 100},
    {'name': '白雪儿', 'score': 65}
]
# 对列表进行排序，排序的规则是字典中的成绩
student_scores.sort(key=lambda x:x.get('score'),reverse=True) # 降序
print(student_scores)
```
输出：
```
30
<class 'function'>
30
------------------------------
10
20
30
40
50
------------------------------
10
20
30
40
50
[{'name': '张天乐', 'score': 100}, {'name': '陈梅梅', 'score': 98}, {'name': '王一一', 'score': 95}, {'name': '白雪儿', 'score': 65}]
```
## 6.递归函数
1. 在一个函数的函数体内调用该函数本身，该函数就是**递归函数**
2. 一个完整的递归操作由两部分组成，一部分是递归调用，一部分是递归终止条件，一般可使用if-else结构来判断递归的调用和递归的终止

**优点**：思路和代码比较简单
**缺点**：占用内存比较多，因为每次去调用一个函数的时候，都会在内部去开辟一个栈帧出来，所以它的效率比较低
![../../../Extras/Media/media-第08章-函数及常用的内置函数-1.png|8-1递归函数阶乘表达](/img/user/Extras/Media/media-%E7%AC%AC08%E7%AB%A0-%E5%87%BD%E6%95%B0%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0-1.png)
举例：
```python
def fac(n): # n的阶乘  N!=N*(N-1)!......1!=1
    if n==1:
        return 1
    else:
        return n*fac(n-1) # 自己调用自己

print(fac(5)) # 5!=5*4*3*2*1    =120
```
输出：
```
120
```
### 斐波那契数列
斐波那契数列（Fibonacci sequence），又称黄金分割线，是因数学家莱昂纳多·斐波那契（Leonardo Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、......，从第三项开始，每项都等于前两项之和
**公式为**：$f(n)=f(n-1)+f(n-2)$
> [!note]- 举例
> ```python
> def fac(n):
>     if n==1 or n==2:
>         return 1
>     else:
>         return fac(n-1)+fac(n-2)
> 
> print(fac(9)) # 第9位上的数字
> 
> for i in range(1,10):
>     print(fac(i),end='\t')
> print()
> ```
> 输出：
> ```
> 34
> 1	1	2	3	5	8	13	21	34	
> 
> ```

# 二、常用的内置函数
内置函数是指不需要使用前缀就可以直接使用的函数。根据函数的功能可以将常用的内置函数分为数据类型转化函数、数学函数、迭代器操作函数以及其他函数。
## 1.数据类型转换函数
|函数名称|描述说明|
|:-:|:-:|
|bool(obj)|获取指定对象obj的布尔值|
|str(obj)|将指定对象obj转成字符串类型|
|int(x)|将x转成int类型|
|float(x)|将x转成float类型|
|list(sequence)|将序列转成列表类型|
|tuple(sequence)|将序列转成元组类型|
|set(sequence)|将序列转成集合类型|
|dict(sequence)|将序列转成字典类型|

> [!note]- 举例
> ```python
> print('非空字符串的布尔值:',bool('hello')) # True
> print('空字符串的布尔值:',bool('')) # 空字符串不是空格字符串
> print('空列表的布尔值:',bool([]))
> print('空列表的布尔值:',bool(list()))
> print('空元组的布尔值:',bool(()))
> print('空元组的布尔值:',bool(tuple()))
> print('空集合的布尔值:',bool(set()))
> print('空字典的布尔值:',bool({}))
> print('空字典的布尔值:',bool(dict()))
> print('-'*30)
> print('非0数值型的布尔值:',bool(123))
> print('整数0的布尔值:',bool(0))
> print('浮点数0.0的布尔值:',bool(0.0))
> 
> # 将其它类型转成字符串类型
> lst=[10,20,30]
> print(type(lst),lst)
> 
> s=str(lst)
> print(type(s),s)
> 
> # float类型和str类型转成int类型
> print('-'*30,'float类型和str类型转成int类型','-'*30)
> print(int(98.7)+int('90'))
> # 注意事项
> # print(int('98.7')) # ValueError: invalid literal for int() with base 10: '98.7'
> # print(int('a')) # ValueError: invalid literal for int() with base 10: 'a'
> 
> print('-'*30,'int,str类型转成float类型','-'*30)
> print(float(90)+float('3.14'))
> 
> s='hello'
> print(list(s))
> 
> seq=range(1,10)
> print(tuple(seq))
> print(set(seq))
> print(list(seq))
> ```
> 输出：
> ```
> 非空字符串的布尔值: True
> 空字符串的布尔值: False
> 空列表的布尔值: False
> 空列表的布尔值: False
> 空元组的布尔值: False
> 空元组的布尔值: False
> 空集合的布尔值: False
> 空字典的布尔值: False
> 空字典的布尔值: False
> ------------------------------
> 非0数值型的布尔值: True
> 整数0的布尔值: False
> 浮点数0.0的布尔值: False
> <class 'list'> [10, 20, 30]
> <class 'str'> [10, 20, 30]
> ------------------------------ float类型和str类型转成int类型 ------------------------------
> 188
> ------------------------------ int,str类型转成float类型 ------------------------------
> 93.14
> ['h', 'e', 'l', 'l', 'o']
> (1, 2, 3, 4, 5, 6, 7, 8, 9)
> {1, 2, 3, 4, 5, 6, 7, 8, 9}
> [1, 2, 3, 4, 5, 6, 7, 8, 9]
> ```

## 2.常用的数学函数
|函数名称|描述说明|
|:-:|:-:|
|abs(x)|获取x的绝对值|
|divmod(x,y)|获取x与y的商和余数|
|max(sequence)|获取sequence的最大值|
|min(sequence)|获取sequence的最小值|
|sum(iter)|对可迭代对象进行求和运算|
|pow(x,y)|获取x的y次幂|
|round(x,d)|对x进行保留d位小数，结果四舍五入|

> [!note]- 举例
> ```python
> print('绝对值:',abs(100),abs(-100),abs(0))
> print('商和余数:',divmod(13,4))
> print('最大值:',max('hello'))
> print('最大值:',max([10,4,56,78,4]))
> print('最小值:',min('hello'))
> print('最小值:',min([10,4,56,78,4]))
> 
> print('求和:',sum([10,34,45]))
> print('x的y次幂:',pow(2,3))
> 
> # 四舍五入
> print(round(3.1415926)) # round函数只有一个参数，保留整数
> print(round(3.9415926)) # 4
> print(round(3.1415926,2)) # 2表示的是保留两位小数
> print(round(314.15926,-1)) # 314，-1位，对个位进行四舍五入
> print(round(314.15926,-2)) # 300，-2，对十位进行四舍五入
> ```
> 输出：
> ```
> 绝对值: 100 100 0
> 商和余数: (3, 1)
> 最大值: o
> 最大值: 78
> 最小值: e
> 最小值: 4
> 求和: 89
> x的y次幂: 8
> 3
> 4
> 3.14
> 310.0
> 300.0
> ```

## 3.迭代器操作函数
|函数名称|描述说明|
|:-:|:-:|
|sorted(iter)|对可迭代对象进行排序|
|reversed(sequence)|反转序列生成新的迭代器对象|
|zip(iter1,iter2)|将iter1与iter2打包成元组并返回一个可迭代的zip对象|
|enumerate(iter)|根据iter对象创建一个enumerate对象|
|all(iter)|判断可迭代对象iter中所有元素的布尔值是否都为True，如果都为True，其结果为True|
|any(iter)|判断可迭代对象iter中所有元素的布尔值是否都为False，如果都为False，其结果为False|
|next(iter)|获取迭代器的下一个元素|
|filter(function,iter)|通过指定条件过滤序列并返回一个迭代器对象|
|map(function,iter)|通过函数function对可选代对象iter的操作返回一个选代器对象|

> [!note]- 举例
> ```python
> lst=[54,56,77,4,567,34]
> # （1）排序操作
> asc_lst=sorted(lst) # 升序
> desc_lst=sorted(lst,reverse=True) # 降序
> print('原列表:',lst)
> print('升序:',asc_lst)
> print('降序:',desc_lst)
> 
> # （2）reversed 反向
> news_lst=reversed(lst)
> print(type(news_lst)) # <class 'list_reverseiterator'> 迭代器对象
> print(list(news_lst))
> 
> # （3）zip
> x=['a','b','c','d']
> y=[10,20,30,40,50]
> zipobj=zip(x,y)
> print(type(zipobj)) # <class 'zip'>
> print(list(zipobj))
> 
> # （4）enumerate
> enum=enumerate(y,start=1)
> print(type(enum)) # <class 'enumerate'>
> print(tuple(enum))
> 
> # （5）all
> lst2=[10,20,'',30]
> print(all(lst2)) # False，空字符串的布尔值是False
> print(all(lst)) # True
> 
> # （6）any
> print(any(lst2)) # True
> # 列表当中所有元素对象的布尔值都为False的时候，其结果才为False
> 
> # （7）next
> x=['a','b','c','d']
> y=[10,20,30,40,50]
> zipobj=zip(x,y)
> print(next(zipobj))
> print(next(zipobj))
> print(next(zipobj))
> 
> 
> # （8）filter
> def fun(num):
>     return num%2==1 # 可能是True，False
> 
> obj=filter(fun,range(10)) # 这里是函数作为参数，不是调用，函数作为参数是不需要写小括号的，写小括号就是调用了
> # 将range(10),0-9的整数，都执行一次fun操作
> print(list(obj)) # [1, 3, 5, 7, 9]
> 
> # （9）map
> def upper(x):
>     return x.upper()
> 
> new_lst2=['hello','world','python']
> obj2=map(upper,new_lst2)
> print(list(obj2))
> ```
> 输出：
> ```
> 原列表: [54, 56, 77, 4, 567, 34]
> 升序: [4, 34, 54, 56, 77, 567]
> 降序: [567, 77, 56, 54, 34, 4]
> <class 'list_reverseiterator'>
> [34, 567, 4, 77, 56, 54]
> <class 'zip'>
> [('a', 10), ('b', 20), ('c', 30), ('d', 40)]
> <class 'enumerate'>
> ((1, 10), (2, 20), (3, 30), (4, 40), (5, 50))
> False
> True
> True
> ('a', 10)
> ('b', 20)
> ('c', 30)
> [1, 3, 5, 7, 9]
> ['HELLO', 'WORLD', 'PYTHON']
> ```

## 4.其它内置函数
|函数名称|描述说明|
|:-:|:-:|
|format(value,format_spec)|将value以format_spec格式进行显示|
|len(s)|获取s的长度或s元素的个数|
|id(obj)|获取对象的内存地址|
|type(x)|获取x的数据类型|
|eval(s)|执行s这个字符串所表示的Python代码|

> [!note]- 举例
> ```python
> # format()
> print(format(3.14,'20')) # 数值型默认右对齐
> print(format('hello','20')) # 字符串默认左对齐
> print(format('hello','*<20')) # <左对齐，*表示的填充符，20表示的是显示的宽度
> print(format('hello','*>20'))
> print(format('hello','*^20'))
> 
> 
> print(format(3.1415926,'.2f')) # 3.14
> print(format(20,'b'))
> print(format(20,'o'))
> print(format(20,'x'))
> print(format(20,'X'))
> 
> print('-'*40)
> print(len('helloworld'))
> print(len([10,20,30,40,50]))
> 
> print('-'*40)
> print(id(10))
> print(id('helloworld'))
> print(type('hello'),type(10))
> 
> print(eval('10+30'))
> print(eval('10>30'))
> ```
> 输出：
> ```
>                 3.14
> hello               
> hello***************
> ***************hello
> *******hello********
> 3.14
> 10100
> 24
> 14
> 14
> ----------------------------------------
> 10
> 5
> ----------------------------------------
> 140729059124424
> 1531445173744
> <class 'str'> <class 'int'>
> 40
> False
> ```

# 章节习题
1. 以下代码的运行结果是
```python
def fun(n):
	if n<0:
		return -1
	elif n==1:
		return 1
	else:
		lst=[2,8]
		for i in range(1,n):
			lst.append(lst[-1]+lst[-2])
			return lst[-2]%lst[-1]
print(fun(7))
```
A．8
B．10
C．0.8
D．-1
> [!note]- 答案
> 答案：A

2. 以下关于全局部变量和局部变量描述错误的是
A．局部变量在生命周期结束后立即释放
B．全局变量一般没有缩进
C．全局变量和局部变量的名称不能相同
D．要想使用局部变量成为全局变量可以使用关键字global

> [!note]- 答案
> 答案：C
> 解析：
> 全局变量和局部变量的名称可以相同，当它们相同的时候，局部变量更具有优先级。

3. 以下关于函数递归，描述错误的是
A．递归函数必须有一个明确的结束条件
B．递归就该函数调用自身
C．递归效率不高，递归层次过多会导致栈溢出
D．每进入一次递归时，问题规模相对于前一次递归要大

> [!note]- 答案
> 答案：D
> 解析：每递归一次，它的规模是缩小的。

4. 以下代码的运行结果是
```python
def fun():
	print('helloworld')
print(type(fun),type(fun()))
```
A．<class 'function'>,<class 'function'>
B．<class 'function'>,<class 'NoneType'>
C．<class 'function'>,<class 'str'>
D．<class 'str'>,<class 'function'>

> [!note]- 答案
> 答案：B
> 解析：
> 这个fun()是个没有返回值的函数，没有返回值的函数在进行调用之后去输出它的类型的时候，它的类型是None，只有B选项里有None。

# 实战
## 三目运算符（三元表达式）
1. 编写函数实现操作符in的功能
**需求**：使用input()从键盘获取一个字符串，判断这个字符串在列表中是否存在（函数体不能使用in），返回结果为True或False

**答案**：
```python
def get_find(s,lst):
    for item in lst:
        if s==item:
            return True
    return False
lst=['hello','world','python']
s=input('请输入您要判断的字符串:')
result=get_find(s,lst)
print('存在' if result else '不存在') # if..else的简写，三元运算符    if result==True，   if result利用到对象的布尔值
```
***
# 参考文献
[1] 杨淑娟.花了2万多买的Python教程全套，现在分享给大家，入门到精通(Python全栈开发教程)\_哔哩哔哩\_bilibili\[EB/OL\].\[2025-09-14\].[花了2万多买的Python教程全套，现在分享给大家，入门到精通(Python全栈开发教程)_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1wD4y1o7AS/)